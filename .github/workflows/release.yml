name: Build and Release

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'src/**'
      - 'build.gradle.kts'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version from build.gradle.kts
        id: get_version
        run: |
          VERSION=$(grep -oP 'version\s*=\s*"\K[^"]+' build.gradle.kts)
          echo "version=v$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: v$VERSION"

      - name: Get current latest tag
        id: get_current_tag
        run: |
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT
          echo "Current latest tag: $CURRENT_TAG"

      - name: Check if version already released
        id: check_version
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          CURRENT="${{ steps.get_current_tag.outputs.current_tag }}"

          # Check if this version tag already exists
          if git rev-parse "$VERSION" >/dev/null 2>&1; then
            echo "Version $VERSION already released, skipping"
            echo "skip_release=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "skip_release=false" >> $GITHUB_OUTPUT
          echo "New version $VERSION will be released"

      - name: Set up JDK 21
        if: steps.check_version.outputs.skip_release != 'true'
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Setup Gradle
        if: steps.check_version.outputs.skip_release != 'true'
        uses: gradle/actions/setup-gradle@v4

      - name: Grant execute permission for gradlew
        if: steps.check_version.outputs.skip_release != 'true'
        run: chmod +x gradlew

      - name: Build distributions
        if: steps.check_version.outputs.skip_release != 'true'
        run: ./gradlew distTar distZip

      - name: Extract release notes from merged PRs
        id: extract_pr_notes
        if: steps.check_version.outputs.skip_release != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PREVIOUS_TAG="${{ steps.get_current_tag.outputs.current_tag }}"

          # Get commits between previous tag and HEAD to find associated PRs
          if [ -n "$PREVIOUS_TAG" ] && [ "$PREVIOUS_TAG" != "v0.0.0" ]; then
            # Get merge commits since the previous tag
            MERGE_COMMITS=$(git log "$PREVIOUS_TAG"..HEAD --merges --pretty=format:"%H" 2>/dev/null || echo "")
          else
            # No previous tag, get all merge commits
            MERGE_COMMITS=$(git log --merges --pretty=format:"%H" 2>/dev/null || echo "")
          fi

          # Initialize section collectors
          FEATURES=""
          BUG_FIXES=""
          BREAKING_CHANGES=""
          SUMMARIES=""

          # Function to extract section content from PR body
          extract_section() {
            local body="$1"
            local section="$2"
            echo "$body" | awk -v section="$section" '
              BEGIN { in_section=0 }
              /^## / { 
                if ($0 ~ "^## " section) { in_section=1; next }
                else { in_section=0 }
              }
              /^---/ { in_section=0 }
              in_section && /^- .+/ { print }
            '
          }

          # Fetch all merged PRs as JSON array and save to file
          gh pr list --state merged --limit 100 --json number,body,mergeCommit > /tmp/prs.json

          # Get PR numbers that were merged since the previous tag
          PR_NUMBERS=""
          if [ -n "$MERGE_COMMITS" ]; then
            for commit in $MERGE_COMMITS; do
              # Find PR number for this merge commit
              pr_num=$(jq -r --arg commit "$commit" '.[] | select(.mergeCommit.oid == $commit) | .number' /tmp/prs.json)
              if [ -n "$pr_num" ]; then
                PR_NUMBERS="$PR_NUMBERS $pr_num"
              fi
            done
          fi

          # If no PRs found via merge commits, try to get PRs merged since tag date
          if [ -z "$PR_NUMBERS" ]; then
            echo "No PRs found via merge commits, trying date-based search..."
            if [ -n "$PREVIOUS_TAG" ] && [ "$PREVIOUS_TAG" != "v0.0.0" ]; then
              SINCE_DATE=$(git log -1 --format=%Y-%m-%d "$PREVIOUS_TAG" 2>/dev/null || echo "1970-01-01")
            else
              SINCE_DATE="1970-01-01"
            fi
            # Get all PR numbers from the JSON file
            PR_NUMBERS=$(jq -r '.[].number' /tmp/prs.json | tr '\n' ' ')
          fi

          echo "Processing PRs: $PR_NUMBERS"

          # Process each PR
          for pr_num in $PR_NUMBERS; do
            [ -z "$pr_num" ] && continue

            # Extract the body for this PR from the JSON
            body=$(jq -r --argjson num "$pr_num" '.[] | select(.number == $num) | .body // ""' /tmp/prs.json)

            [ -z "$body" ] && continue

            echo "Processing PR #$pr_num"

            # Extract Summary (single paragraph after ## Summary)
            summary=$(echo "$body" | awk '
              BEGIN { in_section=0 }
              /^## Summary/ { in_section=1; next }
              /^## / { in_section=0 }
              /^---/ { in_section=0 }
              in_section && /^[^<]/ && !/^$/ { print; exit }
            ')
            [ -n "$summary" ] && SUMMARIES="${SUMMARIES}${summary}"$'\n'

            # Extract Features
            features=$(extract_section "$body" "Features")
            [ -n "$features" ] && FEATURES="${FEATURES}${features}"$'\n'

            # Extract Bug Fixes
            bugfixes=$(extract_section "$body" "Bug Fixes")
            [ -n "$bugfixes" ] && BUG_FIXES="${BUG_FIXES}${bugfixes}"$'\n'

            # Extract Breaking Changes
            breaking=$(extract_section "$body" "Breaking Changes")
            [ -n "$breaking" ] && BREAKING_CHANGES="${BREAKING_CHANGES}${breaking}"$'\n'

          done

          # Set defaults if empty
          [ -z "$SUMMARIES" ] && SUMMARIES="See individual changes below."
          [ -z "$FEATURES" ] && FEATURES="- None"
          [ -z "$BUG_FIXES" ] && BUG_FIXES="- None"
          [ -z "$BREAKING_CHANGES" ] && BREAKING_CHANGES="- None"

          # Write to temp files (handles multiline content)
          echo "$SUMMARIES" > /tmp/summaries.txt
          echo "$FEATURES" > /tmp/features.txt
          echo "$BUG_FIXES" > /tmp/bugfixes.txt
          echo "$BREAKING_CHANGES" > /tmp/breaking.txt

          # Debug output
          echo "=== Extracted Content ==="
          echo "Features:"
          cat /tmp/features.txt
          echo "Bug Fixes:"
          cat /tmp/bugfixes.txt
          echo "Breaking Changes:"
          cat /tmp/breaking.txt

      - name: Generate release notes from template
        if: steps.check_version.outputs.skip_release != 'true'
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          PREVIOUS_TAG="${{ steps.get_current_tag.outputs.current_tag }}"
          REPO="${{ github.repository }}"

          # Read extracted PR content
          SUMMARY=$(cat /tmp/summaries.txt)
          FEATURES=$(cat /tmp/features.txt)
          BUG_FIXES=$(cat /tmp/bugfixes.txt)
          BREAKING_CHANGES=$(cat /tmp/breaking.txt)

          # Read template
          NOTES=$(cat .github/RELEASE_TEMPLATE.md)

          # Substitute variables using sed for multiline content
          echo "$NOTES" | \
            sed "s|\${VERSION}|$VERSION|g" | \
            sed "s|\${REPO}|$REPO|g" | \
            sed "s|\${PREVIOUS_TAG}|$PREVIOUS_TAG|g" > release_notes.md

          # Replace section placeholders with content
          sed -i "s|\${SUMMARY}|$SUMMARY|g" release_notes.md

          # Use awk for multiline replacements
          awk -v features="$FEATURES" '{gsub(/\${FEATURES}/, features)}1' release_notes.md > tmp && mv tmp release_notes.md
          awk -v bugfixes="$BUG_FIXES" '{gsub(/\${BUG_FIXES}/, bugfixes)}1' release_notes.md > tmp && mv tmp release_notes.md
          awk -v breaking="$BREAKING_CHANGES" '{gsub(/\${BREAKING_CHANGES}/, breaking)}1' release_notes.md > tmp && mv tmp release_notes.md

      - name: Create version tag
        if: steps.check_version.outputs.skip_release != 'true'
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$VERSION" -m "Release $VERSION"
          git push origin "$VERSION"
          echo "Created and pushed tag: $VERSION"

      - name: Upload distribution artifacts
        if: steps.check_version.outputs.skip_release != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: distributions
          path: |
            build/distributions/*.tar
            build/distributions/*.zip

      - name: Create Release
        if: steps.check_version.outputs.skip_release != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_version.outputs.version }}
          name: Release ${{ steps.get_version.outputs.version }}
          draft: false
          prerelease: false
          files: |
            build/distributions/*.tar
            build/distributions/*.zip
          body_path: release_notes.md
